import pandas as pd
import heapq 

resources_df = pd.read_excel('resources.xlsx')
state_df = pd.read_excel('initial_state.xlsx')

def state_quality(country: str):
	country_df = state_df[state_df['Country'] == country]
	country_index = country_df.index.tolist()[0]
	population = country_df['R1'].iloc[country_index]
	
	weighted_sum = 0.0
	for resource in country_df:
		if resource != 'Country':
			resource_quantity = country_df[resource].iloc[country_index]
			resource_value = resources_df[resources_df['Resources'] == resource]['Weight'].iloc[0]
			weighted_sum = weighted_sum + (resource_quantity * resource_value)

	return weighted_sum / population

# For testing
print(state_quality('Atlantis'))


# This is a template for the scheduler. It uses a fix-sized priority queue 
# with (maxSize) to queue and explore the potential actions taken by countries.
# It returns the best schedule (the one that generates the highest expected
# utility for our country) with the corresponding utility of each step
#
# Todo:
# 1. implement the world class or equilvalent. Expects the following methods:
#    a. __init__(self, myCountry, actionList): stores the given (myCountry), which is the
#       name of our chosen country, and (actionList), which is the list of proposed actions
#    b. getStartState(): returns the initial state of the world (parsed .xlsx)
#    c. getSuccessors(state): returns a list of successors: [state, action] generated by 
#       applying one single action from actionList.
# 2. implement the expected utility function, which is used to calculate the utility score
#     mentioned in 1). Expects the following signature:
#     expectedUtility(resources, partialSchedule), where resources is a list of the current 
#     resources of a country and partialSchedule is a list of actions taken so far
def search(world, eu,myCountry, maxDepth, maxSize):
	scheduler = []
	visited = []
	candidate = []
	result = []
	maxUtility = float('-inf')
	initialState = world.getStartState()
	heapq.heappush(scheduler, (float('-inf'), initialState, [], 0))
	while not scheduler.isEmpty():
		cur = heapq.heappop(scheduler)
		utility = cur[0]
		state = cur[1]
		actions = cur[2]
		depth = cur[3]
		# reaches maximum depth
		if depth == maxDepth:
			if utility >= maxUtility:
				result = candidate.copy()
				maxUtility = utility
				candidate.pop()
		# explores current state if new
		if state not in visited:
			visited.append(state)
			if actions:
				candidate.push((actions[-1], utility))
			# expands fringe
			for successor in world.getSuccessors(state):
				nextState = successor[0]
				nextAction = successor[1]
				# evaluates the expected utility
				partialSchedule = actions + [nextAction]
				nextUtility = eu(nextState[myCountry], partialSchedule)
				if nextState not in visited:
					heapq.heappush(scheduler, (nextUtility, nextState, partialSchedule, depth + 1))
					# maintains a fix-sized heap
					if len(scheduler) > maxSize:
						heapq.heappop(scheduler)
	return result